from .  import app, cache, db, scheduler
from flask import request, jsonify, send_file
from werkzeug.security import check_password_hash
from .Sqlmodels.User import User
from .Sqlmodels.Endpoint import Endpoint
from .Sqlmodels.StorageNode import StorageNode
from .Sqlmodels.ZeroCryptor import ZeroCryptor
from .Sqlmodels.ESNPair import ESNPair
from .Sqlmodels.BackupJob import BackupJob
from .Sqlmodels.ScheduledJob import ScheduledJob
import os, sys,jwt, logging, paramiko, uuid
from datetime import datetime, timezone
import time
import threading

class Zeroapi:
    backup_in_progress = 0
    backup_with_errors = {}
    backup_with_success = {}

    @app.route('/zeroapi/v1/adduser', methods=['GET'])
    def adduser():
        newuser  = User(first_name="Rushawn",last_name="Campbell",email="rushawn.campbell@mymona.uwi.edu", username="admin", password="admin123")
        db.session.add(newuser)
        db.session.commit()
        print("status ok user added")
        return jsonify({"stat": "ok user added"})
    #LLog in User
    @app.route('/zeroapi/v1/login', methods=['POST'])
    def login():
        user = None
        if request.method == "POST":
            data = request.get_json()
            uname = data.get('username')
            password = data.get('password')
            user = User.query.filter_by(username=uname).first()
            if user is not None and check_password_hash(user.password, password):
                tokencreationtime = datetime.now(timezone.utc).strftime("%H:%M:%S")
                token  = jwt.encode({'sub':uname,'initime': tokencreationtime}, app.config.get('SECRET_KEY'),algorithm='HS256')  
                return jsonify({
                    "zauth_token": token
                }),200
            else:
                return jsonify({
                    "message": "Login failed, check your username and password then try again.",
                }),401


    #Logout User
    @app.route('/zeroapi/v1/logout', methods=['GET'])
    def logout():
        if request.method == 'GET':
            return jsonify({
            "message": "Log out successful"
        }),200
            
    #Downloads Storage/Endpoint Installers
    @app.route('/zeroapi/v1/download/<download_type>', methods=['GET'])
    def download(download_type):
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                try:
                    filename = f'{download_type}.zip'
                    file_path = os.path.join(app.root_path,"..\\","dist", filename) 
        
                    return send_file(
                        file_path,
                        as_attachment=True,
                        download_name=filename  
                    )
                except FileNotFoundError:
                   return jsonify({
                            "message": "The requested resource could not be found. Contact the ZeroDown Support for help.",
                        }),404
                except Exception as e:
                    return jsonify({
                            "message": "Something went wrong. Contact the ZeroDown Support for help.",
                        }),500

        except Exception as e:
            return jsonify({"message": "Access token is missing or invalid"}),401
        
    @app.route('/zeroapi/v1/test_connection', methods=['POST'])
    def test_connection():
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                try:
                    data = request.get_json()
                    hostname= data.get('hostname')
                    username=data.get('authorized_user')
                    reg_type=data.get('reg_type')
                    pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
                    
                    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
                    client = paramiko.SSHClient()
                    client.load_system_host_keys()
                    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
                    client.connect(hostname=hostname, username=username,  pkey=pkey)
                    if reg_type == "storagenode":
                        command = "type %USERPROFILE%\\.ssh\\id_rsa.pub"
                        stdin, stdout, stderr = client.exec_command("cmd.exe /c \"" + command + "\"")
                        fetched_pub = stdout.read().decode().strip()
                        error = stderr.read().decode().strip()
                        if not error:
                            return jsonify({"response": fetched_pub}),200
                        return jsonify({"response": fetched_pub}),401
                    client.close()
                    del pkey
                    return jsonify({"response": "Connection Successful"}),200
                except Exception as e:
                    print(e)
                    return jsonify({
                            "response": "Something went wrong. Contact the ZeroDown Support for help.",
                        }),500
            else:
                return jsonify({"response": "Access token is missing or invalid"}),401

        except Exception as e:
            return jsonify({"response": "Access token is missing or invalid"}),401
        


    @app.route('/zeroapi/v1/register/<register_type>', methods=['POST'])
    def register_endpoint(register_type):
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                data = request.get_json()
                object_name = data.get('name')
                object_ip= data.get('ip')
                object_user=data.get('authorized_user')
                if register_type == "endpoint":
                    endpoint_object = Endpoint(ip=object_ip, name=object_name, username=object_user)
                    db.session.add(endpoint_object)
                    db.session.commit()
                    return jsonify({"message": "Endpoint Node Registered"}),200
                if register_type == "storagenode":
                    pub_key=data.get('pub_key')
                    storage_object = StorageNode(ip=object_ip, name=object_name, username=object_user,pub_key=pub_key)
                    db.session.add(storage_object)
                    db.session.commit()
                    return jsonify({"message": "Storage Node Registered"}),200
            else:
                return jsonify({"message": "Access token is missing or invalid"}),401
        except Exception as e:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            line_number = exc_traceback.tb_lineno
            print(f"An exception occurred: {e}")
            print(f"Line number: {line_number}")
            return jsonify({"message": "Access token is missing or invalid"}),401
        
    @app.route('/zeroapi/v1/objects/<object_type>', methods=['GET'])
    def objects(object_type):
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                try:
                    if object_type == "endpoints":
                        fetched_endpoints = Endpoint.query.all()
                        endpoints = []
                        for endpoint in fetched_endpoints:
                            endpoints.append({
                                "endpoint_id" : endpoint.id,
                                "endpoint_name": endpoint.name,
                                "endpoint_reg_date": endpoint.created.strftime("%Y-%m-%d %H:%M:%S")
                            })
                        return jsonify({
                            "response" : endpoints
                        })
                    elif object_type == "storagenodes":
                        fetched_storage_nodes = StorageNode.query.all()
                        storagenodes = []
                        for storagenode in fetched_storage_nodes:
                            storagenodes.append({
                                "storage_id" : storagenode.id,
                                "storage_name": storagenode.name,
                                "storage_reg_date": storagenode.created.strftime("%Y-%m-%d %H:%M:%S")
                            })

                        return jsonify({
                            "response" : storagenodes
                        })
                    elif object_type == "endpoint_names":
                        fetched_endpoints = Endpoint.query.all()
                        endpoint_names = []
                        for endpoint in fetched_endpoints:
                            endpoint_names.append(endpoint.name)
                        return jsonify({
                            "response" : endpoint_names
                        })
                    elif object_type == "storage_names":
                        fetched_storage_nodes = StorageNode.query.all()
                        storage_node_names = []
                        for storage_node in fetched_storage_nodes:
                            storage_node_names.append(storage_node.name)

                        return jsonify({
                            "response" : storage_node_names
                        })
                    elif object_type == "scheduled_jobs":
                        fetched_scheduled_jobs = ScheduledJob.query.all()
                        scheduled_jobs = []
                        for scheduled_job in fetched_scheduled_jobs:
                            scheduled_jobs.append({
                                "job_id" : scheduled_job.existing_job.id,
                                "job_name": scheduled_job.existing_job.name,
                                "last_backup": scheduled_job.existing_job.last_backup.strftime("%Y-%m-%d %H:%M:%S"),
                                "next_backup": scheduled_job.next_sch_datetime.strftime("%Y-%m-%d %H:%M:%S")
                            })

                        return jsonify({
                            "response" : scheduled_jobs
                        })
                    return jsonify({"message": "??"})
                except Exception as e:
                    exc_type, exc_value, exc_traceback = sys.exc_info()
                    line_number = exc_traceback.tb_lineno
                    print("EXCEPTION TYPE", exc_type)
                    print("EXCEPTION MESSAGE", exc_value)
                    print("EXCEPTION LINE", line_number)
                    return jsonify({
                            "message": "Something went wrong. Contact the ZeroDown Support for help.",
                        }),500
        except Exception as e:
            return jsonify({"message": "Access token is missing or invalid"}),401
        

    @app.route('/zeroapi/v1/endpoint/listing/<endpoint_name>', methods=['GET'])
    def listing(endpoint_name):
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():

                fetched_endpoint= Endpoint.query.filter_by(name=endpoint_name).first()
                cache.set(f'{namepart}_current_endpoint', fetched_endpoint)
                logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
                try:
                    zcryptobj= ZeroCryptor()
                    encrypted_hostname= fetched_endpoint.ip
                    hostname = zcryptobj._decrypt_data(encrypted_data=encrypted_hostname, type="ENDPOINT")
                    username= fetched_endpoint.username
                    pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
                    client = paramiko.SSHClient()
                    client.load_system_host_keys()
                    client.set_missing_host_key_policy(paramiko.RejectPolicy())
                    client.connect(hostname=hostname, username=username, port=22, pkey=pkey)
                    command= r"""$Volumes = Get-CimInstance -ClassName Win32_Volume | Select-Object DriveLetter, DeviceID, @{Name='UsedSpaceGB';Expression={[math]::Round(($_.Capacity - $_.FreeSpace) / 1GB, 2)}}; $Output = @{}; foreach ($Volume in $Volumes) { if ($Volume.DriveLetter) { $Output[$Volume.DriveLetter] = @{"DeviceID" = $Volume.DeviceID; "UsedSpaceGB" = $Volume.UsedSpaceGB} } }; $Output | ConvertTo-Json -Depth 5"""
                    _, stdout, stderr = client.exec_command(f'powershell.exe -ExecutionPolicy Bypass -Command "{command}"', timeout=999)
                    vol_dict= stdout.read().decode('utf-8').strip()
                    error = stderr.read().decode('utf-8').strip()
                    client.close()
                    if not error:
                        return jsonify(vol_dict),200
                    else:
                        return jsonify({"response": "nothing found or an error occurred"}),401
                except Exception as e:
                    print(e)
                    return jsonify({
                        "response": "Something went wrong. Contact the ZeroDown Support for help.",
                    }),500
        except Exception as e:
            print(e)
            return jsonify({
                    "response": "Something went wrong. Contact the ZeroDown Support for help.",
            }),500
        

    @app.route('/zeroapi/v1/storage/volumes/<storage_name>', methods=['GET'])
    def volumes(storage_name):
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():

                fetched_storage= StorageNode.query.filter_by(name=storage_name).first()
                cache.set(f'{namepart}_current_storage_node', fetched_storage)
                logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
                try:
                    zcryptobj= ZeroCryptor()
                    encrypted_hostname= fetched_storage.ip
                    hostname = zcryptobj._decrypt_data(encrypted_data=encrypted_hostname, type="STORAGE")
                    username= fetched_storage.username
                    pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
                    client = paramiko.SSHClient()
                    client.load_system_host_keys()
                    client.set_missing_host_key_policy(paramiko.RejectPolicy())
                    client.connect(hostname=hostname, username=username, port=22, pkey=pkey)
                    command = r"""$Volumes = Get-CimInstance -ClassName Win32_Volume | Select-Object DriveLetter, DeviceID, @{Name='AvailableSpaceGB';Expression={[math]::Round(($_.FreeSpace) / 1GB, 2)}}; $Output = @{}; foreach ($Volume in $Volumes) { if ($Volume.DriveLetter) { $Output[$Volume.DriveLetter] = @{"DeviceID" = $Volume.DeviceID; "AvailableSpaceGB" = $Volume.AvailableSpaceGB} } }; $Output | ConvertTo-Json -Depth 5"""
                    _, stdout, stderr = client.exec_command(f'powershell.exe -ExecutionPolicy Bypass -Command "{command}"', timeout=999)
                    vol_dict= stdout.read().decode('utf-8').strip()
                    error = stderr.read().decode('utf-8').strip()
                    client.close()
                    if not error:
                        return jsonify(vol_dict),200
                    else:
                        return jsonify({"response": "nothing found or an error occurred"}),401
                except Exception as e:
                    print(e)
                    return jsonify({
                        "response": "Something went wrong. Contact the ZeroDown Support for help.",
                    }),500
        except Exception as e:
            print(e)
            return jsonify({
                    "response": "Something went wrong. Contact the ZeroDown Support for help.",
            }),500


    @app.route('/zeroapi/v1/endpoint/backupdemand/<endpoint_name>', methods=['POST'])
    def backupdemand(endpoint_name):
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                data = request.get_json()
                fetched_endpoint= Endpoint.query.filter_by(name=endpoint_name).first()
                zcryptobj= ZeroCryptor()
                encrypted_hostname= fetched_endpoint.ip
                hostname = zcryptobj._decrypt_data(encrypted_data=encrypted_hostname, type="ENDPOINT")
                username= fetched_endpoint.username
                pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
                client = paramiko.SSHClient()
                client.load_system_host_keys()
                client.set_missing_host_key_policy(paramiko.RejectPolicy())
                client.connect(hostname=hostname, username=username, port=22, pkey=pkey)
                for drive in data:
                    for path,size in data[drive]:
                        command= f'(Get-ChildItem -Path {path} -Force | Measure-Object -Property Length -Sum).Sum'
                        _, stdout, stderr = client.exec_command(f'powershell.exe -ExecutionPolicy Bypass -Command "{command}"', timeout=999)
                        object_size = stdout.read().decode('utf-8').strip()
                        error = stderr.read().decode('utf-8').strip()
                        data[drive][path] = object_size
                    pass
                return jsonify({
                    "response": "DATA IS ",
                }),200

        except Exception as e:
            print(e)
            return jsonify({
                    "response": "Something went wrong. Contact the ZeroDown Support for help.",
            }),500


    @app.route('/zeroapi/v1/backup/restore', methods=['POST'])
    def restore():
        user_token= request.headers['Authorization'].split(' ')[1]
        if not user_token:
            return jsonify({"message": "Access token is missing or invalid"}),401
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart= decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                pass
        except Exception as e:
            print(e)
            return jsonify({"response":  -1}),500
        

    @app.route('/zeroapi/v1/backup/first_time', methods=['POST'])
    def first_time():
        user_token = request.headers.get('Authorization', '').split(' ')[-1]
        if not user_token:
            return jsonify({"response": -1}),500
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart = decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart != fetched_user.username.lower():
                return jsonify({"response": -1}),500
            
            data = request.get_json()
    
            fetched_endpoint = cache.get(f'{namepart}_current_endpoint')
            fetched_storage = cache.get(f'{namepart}_current_storage_node')
    
            zcryptobj = ZeroCryptor()
            storage_node_pub_key = zcryptobj._decrypt_data(encrypted_data=fetched_storage.pub_key, type="STORAGE")
            storage_node_ip = zcryptobj._decrypt_data(encrypted_data=fetched_storage.ip, type="STORAGE")
            storage_node_username = fetched_storage.username
            storage_node_id = fetched_storage.id
            endpoint_ip = zcryptobj._decrypt_data(encrypted_data=fetched_endpoint.ip, type="ENDPOINT")
            endpoint_username = fetched_endpoint.username
            endpoint_id = fetched_endpoint.id
            storage_client, pairing_sftp_exit_code, isexists_code,  isexists_esn_pair_id = Zeroapi.PairESN(storage_node_id, storage_node_pub_key, storage_node_ip, storage_node_username, endpoint_id, endpoint_ip, endpoint_username)
    
            if pairing_sftp_exit_code != 0:
                return jsonify({"response": pairing_sftp_exit_code}), 500
    
            if isexists_code == 0:
                esnpair_id = str(uuid.uuid4())
                espnobj = ESNPair( storage_node_id= storage_node_id, endpoint_id= endpoint_id, id=esnpair_id)
                db.session.add(espnobj)
                db.session.commit()
            else:
                esnpair_id = isexists_esn_pair_id
    
            selected_storage_volumes = data.get('backup_destinations')
            remote_folder = f"C:\\Users\\{endpoint_username}\\Desktop"
            job_id = str(uuid.uuid4())
    
   
            threading.Thread(target=Zeroapi.run_backup_thread, args=(storage_client, endpoint_username, endpoint_ip, remote_folder, selected_storage_volumes, job_id)).start()
            #job_name = data.get('name')
            #backupjob = BackupJob( esnpair=esnpair_id, name=job_name, target=str(data.get('backup_targets')), destination=str(data.get('backup_destinations')), id=job_id)
            #db.session.add(backupjob)
            #db.session.commit()
            return jsonify({"in_progress": len(selected_storage_volumes), "job_id":job_id }), 200
    
        except Exception as e:
            print("ERROR IS", e)
            return jsonify({"in_progress": -1}),500
        
    
    @app.route('/zeroapi/v1/backup/schedule', methods=['POST'])
    def schedule():
        user_token = request.headers.get('Authorization', '').split(' ')[-1]
        if not user_token:
            return jsonify({"response": -1}),500
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart = decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart != fetched_user.username.lower():
                return jsonify({"response": -1}),500
            data = request.get_json()
            
            fetched_endpoint = cache.get(f'{namepart}_current_endpoint')
            fetched_storage = cache.get(f'{namepart}_current_storage_node')

            zcryptobj = ZeroCryptor()
            storage_node_pub_key = zcryptobj._decrypt_data(encrypted_data=fetched_storage.pub_key, type="STORAGE")
            storage_node_ip = zcryptobj._decrypt_data(encrypted_data=fetched_storage.ip, type="STORAGE")
            storage_node_username = fetched_storage.username
            storage_node_id = fetched_storage.id
            endpoint_ip = zcryptobj._decrypt_data(encrypted_data=fetched_endpoint.ip, type="ENDPOINT")
            endpoint_username = fetched_endpoint.username
            endpoint_id = fetched_endpoint.id
            storage_client, pairing_sftp_exit_code, isexists_code,  isexists_esn_pair_id = Zeroapi.PairESN(storage_node_id, storage_node_pub_key, storage_node_ip, storage_node_username, endpoint_id, endpoint_ip, endpoint_username)
            storage_client.close()

            if pairing_sftp_exit_code != 0:
                return jsonify({"response": "Preflight Test Failed, We Couldn't Connect Your Endpoint To The Storage Node. Verify that SSH Server Service is running on both."}), 500
    
            if isexists_code == 0:
                esnpair_id = str(uuid.uuid4())
                espnobj = ESNPair( storage_node_id=storage_node_id, endpoint_id= endpoint_id, id=esnpair_id)
                db.session.add(espnobj)
                db.session.commit()
            else:
                esnpair_id = isexists_esn_pair_id
                
    
            job_id = str(uuid.uuid4())
            job_name = data.get('name')

            backupjob = BackupJob( esnpair=esnpair_id, name=job_name, target=str(data.get('backup_targets')), destination=str(data.get('backup_destinations')), id=job_id)
            db.session.add(backupjob)
            db.session.flush()
            
            sch_id = str(uuid.uuid4())
            sch_datetime = data.get('sch_datetime')
            sch_datetime = datetime.strptime(sch_datetime, '%Y-%m-%d %H:%M:%S')
            sch_frequency = data.get('sch_frequency')
            sch_day = data.get('sch_day')


            if sch_frequency == "Weekly":
                scheduled_job = ScheduledJob(job_id=job_id, frequency=sch_frequency, sch_datetime = sch_datetime, id=sch_id, sch_day = sch_day )
            else:
                scheduled_job = ScheduledJob(job_id=job_id, frequency=sch_frequency, sch_datetime = sch_datetime, id=sch_id)
            
            db.session.add(scheduled_job)
            db.session.commit()

            selected_storage_volumes = data.get('backup_destinations')

            if sch_frequency == "One Time":
                print("Attempting to schedule job Once...") 
                scheduler.add_job(
                    func=Zeroapi.run_scheduled_backup,
                    trigger='date',
                    run_date=sch_datetime,
                    args=[job_id, sch_id, selected_storage_volumes ],  
                    id=job_id+":"+sch_id,  
                    replace_existing=True
                )
            elif sch_frequency == "Daily":
                scheduler.add_job(
                    func=Zeroapi.run_scheduled_backup,
                    trigger='cron',
                    hour=sch_datetime.hour,
                    minute=sch_datetime.minute,
                    args=[job_id, sch_id, selected_storage_volumes],
                    id=job_id+":"+sch_id,
                    replace_existing=True
                   )
            elif sch_frequency == "Weekly":
                scheduler.add_job(
                    func=Zeroapi.run_scheduled_backup,
                    trigger='cron',
                    day_of_week=sch_day, 
                    hour=sch_datetime.hour,
                    minute=sch_datetime.minute,
                    args=[job_id, sch_id, selected_storage_volumes],
                    id=job_id+":"+sch_id,
                    replace_existing=True
                )

            elif sch_frequency == "Monthly":
                scheduler.add_job(
                    func=Zeroapi.run_scheduled_backup,
                    trigger='cron',
                    day=sch_datetime.day,
                    hour=sch_datetime.hour,
                    minute=sch_datetime.minute,
                    args=[job_id,sch_id, selected_storage_volumes],
                    id=job_id+":"+sch_id,
                    replace_existing=True
                )
 
            return jsonify({"response": "Your Backup Job Was Created And Will Execute As Scheduled"}), 200

        except Exception as e:
            print("ERROR IS", e)
            return jsonify({"in_progress": -1}),500
        
        
    @app.route('/zeroapi/v1/backup/get_status', methods=['POST'])
    def get_status():
        user_token = request.headers.get('Authorization', '').split(' ')[-1]
        if not user_token:
            return jsonify({"response": -1}),500
        try:
            decoded = jwt.decode(user_token, app.config['SECRET_KEY'], algorithms=['HS256'])
            namepart = decoded['sub'].lower()
            fetched_user = User.query.filter_by(username=namepart).first()
            if namepart == fetched_user.username.lower():
                job_id = request.get_json()
                job_id = job_id.get('job_id')
            if job_id in Zeroapi.backup_with_success and job_id in Zeroapi.backup_with_errors:
                return jsonify({"success":  Zeroapi.backup_with_success[job_id], "error" : Zeroapi.backup_with_errors[job_id] }),200
            elif job_id not in Zeroapi.backup_with_success and job_id in Zeroapi.backup_with_errors:
                return jsonify({"success":  [], "error" : Zeroapi.backup_with_errors[job_id] }),200
            elif job_id in Zeroapi.backup_with_success and job_id not in Zeroapi.backup_with_errors:
                return jsonify({"success":  Zeroapi.backup_with_success[job_id], "error" : [] }),200
            else:
                return jsonify({"success": [], "error" : [] }),200
        except Exception as e:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            line_number = exc_traceback.tb_lineno
            return jsonify({"response": -1}),500

    #UTILITY FUNCTIONS
    @staticmethod
    def run_backup(storage_client, endpoint_username, endpoint_ip, commands):
        try:
            command = f'sftp -oBatchMode=yes {endpoint_username}@{endpoint_ip}'
            stdin, stdout, stderr = storage_client.exec_command(command)

            output = ""
            error_output = ""
            for cmd in commands:
                stdin.write(cmd + "\n")
                stdin.flush()
                time.sleep(0.1)  

            stdin.close()  

            while not stdout.channel.exit_status_ready():
                if stdout.channel.recv_ready():
                    output += stdout.read().decode()
                if stderr.channel.recv_ready():
                    error_output += stderr.read().decode()
                time.sleep(0.1)

            exit_code = stdout.channel.recv_exit_status()
            storage_client.close()
            return output, error_output, exit_code

        except Exception as e:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            line_number = exc_traceback.tb_lineno
            print(f"Error running remote SFTP: {e}", "LINE NUMBER IS", line_number)
            return None, None, -1
    
    @staticmethod
    def PairESN(storage_node_id,storage_node_pub_key, storage_node_ip, storage_node_username, endpoint_id, endpoint_ip, endpoint_username):
        isexist =  ESNPair.query.filter(ESNPair.storage_node_id == storage_node_id, ESNPair.endpoint_id == endpoint_id).first()
        if isexist != None:
            pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
            storage_client = paramiko.SSHClient()
            storage_client.load_system_host_keys()
            storage_client.set_missing_host_key_policy(paramiko.RejectPolicy())
            storage_client.connect(hostname=storage_node_ip, username=storage_node_username, port=22, pkey=pkey)
            command =  f'sftp -oBatchMode=yes {endpoint_username}@{endpoint_ip}'
            stdin, stdout, stderr = storage_client.exec_command(command)
            stdin.write("bye\n")
            stdin.flush()
            stdin.close()
            error = stderr.read().decode().strip()
            output = stdout.read().decode().strip()
            sftp_exit_code = stdout.channel.recv_exit_status()
            return storage_client, sftp_exit_code, -2, isexist.id
        else:
            pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
            endpoint_client = paramiko.SSHClient()
            endpoint_client.load_system_host_keys()
            endpoint_client.set_missing_host_key_policy(paramiko.RejectPolicy())
            endpoint_client.connect(hostname=endpoint_ip, username=endpoint_username, port=22, pkey=pkey)
            command = f'Add-Content -Path "$env:USERPROFILE\\.ssh\\authorized_keys" -Value \\"`n{storage_node_pub_key}\\"'
            _, stdout, stderr = endpoint_client.exec_command(f'powershell.exe -ExecutionPolicy Bypass -Command "{command}"', timeout=999)
            error = stderr.read().decode('utf-8').strip()
            endpoint_client.close()
            if not error:
                storage_client = paramiko.SSHClient()
                storage_client.load_system_host_keys()
                storage_client.set_missing_host_key_policy(paramiko.RejectPolicy())
                storage_client.connect(hostname=storage_node_ip, username=storage_node_username, port=22, pkey=pkey)
                command =  f'sftp -oBatchMode=yes {endpoint_username}@{endpoint_ip}'
                stdin, stdout, stderr = storage_client.exec_command(command)
                stdin.write("bye\n")
                stdin.flush()
                stdin.close()
                error = stderr.read().decode().strip()
                output = stdout.read().decode().strip()
                sftp_exit_code = stdout.channel.recv_exit_status()
                return storage_client,sftp_exit_code, 0, None
            else:
                return _, -1, -1, None
            
    @staticmethod
    def handle_sftp_result(output, error_output, backup_exit_code):
       if backup_exit_code == 0 and not error_output:
           print("BACKUP WAS SUCCESSSSSSSS!")
           return backup_exit_code
       else:
           print(f"Remote SFTP failed. Exit code: {backup_exit_code}, Error: {error_output}")
           return -1
       
    @staticmethod
    def run_backup_thread(storage_client, endpoint_username, endpoint_ip, remote_folder,selected_storage_volumes, job_id):
        if "Volumes" in selected_storage_volumes:
            selected_storage_volumes_list = selected_storage_volumes['Volumes'].keys()
            for vol in selected_storage_volumes_list:
                backup_destination = f'{vol}\\'
                sftp_commands = [
                    f'get -r {remote_folder} {backup_destination}',
                    'bye'
                ]
                output, error_output, backup_exit_code = Zeroapi.run_backup(storage_client, endpoint_username, endpoint_ip, sftp_commands)
                result = Zeroapi.handle_sftp_result(output, error_output, backup_exit_code)
                
                if result == 0:
                    if job_id in Zeroapi.backup_with_success:
                        Zeroapi.backup_with_success[job_id].append(vol)
                    else:
                        Zeroapi.backup_with_success[job_id] = [vol]
                else:
                    if job_id in Zeroapi.backup_with_errors:
                        Zeroapi.backup_with_errors[job_id].append(vol)
                    else:
                        Zeroapi.backup_with_errors[job_id] = [vol]
            storage_client.close()
    
    @staticmethod
    def UnPairESN(storage_node_id,storage_node_pub_key, storage_node_ip, storage_node_username, endpoint_id, endpoint_ip, endpoint_username):
        pass #for later

    @staticmethod
    def run_scheduled_backup(job_id, sch_id, selected_storage_volumes):

        with app.app_context():
            zcryptobj = ZeroCryptor()
            backupjob = BackupJob.query.filter_by(id=job_id).first()
            storage_node_ip = backupjob.esn_pair.storage_node.ip
            storage_node_ip = zcryptobj._decrypt_data(encrypted_data=storage_node_ip, type="STORAGE")
            storage_node_username = backupjob.esn_pair.storage_node.username
            endpoint_username = backupjob.esn_pair.endpoint.username
            endpoint_ip = backupjob.esn_pair.endpoint.ip
            endpoint_ip = zcryptobj._decrypt_data(encrypted_data=endpoint_ip, type="ENDPOINT")
            remote_folder = f"C:\\Users\\{endpoint_username}\\Desktop"

            pkey = paramiko.RSAKey.from_private_key_file(app.config.get('Z_KEY_PATH'))
            storage_client = paramiko.SSHClient()
            storage_client.load_system_host_keys()
            storage_client.set_missing_host_key_policy(paramiko.RejectPolicy())
            storage_client.connect(hostname=storage_node_ip, username=storage_node_username, port=22, pkey=pkey)

            threading.Thread(target=Zeroapi.run_backup_thread, args=(storage_client, endpoint_username, endpoint_ip, remote_folder, selected_storage_volumes, job_id)).start()
        
            job = scheduler.get_job(f"{job_id}:{sch_id}")
            print("AP JOB ID IS", job)
            if job:
                trigger_type= job.trigger.__class__.__name__
                print("TRIGGER TYPE IS", trigger_type)
                if trigger_type == "CronTrigger":
                    print("IN CRON SCHEDULE", trigger_type )
                    next_run_time = job.next_run_time
                    return next_run_time
                else:
                    job_sch_id = job_id.split(":")[1]
                    if job_sch_id:
                        print("IN ONE TIME SCHEDULE", job_sch_id)
                        fetched_schedule = ScheduledJob.query.filter_by(id=job_sch_id).first()
                        fetched_backup_job = BackupJob.query.filter_by(id=fetched_schedule.existing_job.id).first()
                        db.session.delete(fetched_schedule)
                        db.session.flush()
                        db.session.delete(fetched_backup_job)
                        db.session.commit() 
                    return None
            return -1
    
    """@staticmethod
    def remove_all_jobs():
        jobs = scheduler.get_jobs()
        for job in list(jobs):  
            print(f"  Removing job with ID: {job.id}")
            scheduler.remove_job(job.id)
        print("All jobs have been removed.")"""




import customtkinter as gui, traceback, json, requests, tkinter as tk
from PIL import Image
from frontend.components.RemoteExplorer import RemoteExplorer
from frontend.components.JobStatus import JobStatus
from frontend.components.ScheduleJob import ScheduleJob
from frontend.Utility.CommonMethods import CommonMethods

class Backupjob(gui.CTkFrame):
    def __init__(self, master):
        super().__init__(master)
        self.master = master
        self.master.title("ZeroDown: Create Backup Job")
        self.grid(row=0, column=0, padx=20, pady=20, sticky="nsew")
        self.endpoint_name = None
        self.storage_node_dropdown = None
        self.selected_storage = None
        self.backup_job_name =None
        self.create_widgets()
        self.backup_demand =  0.00
        self.available_storage_size = 0.00
        self.volumes_with_size = {}
        self.volumes = []
        self.selected_endpoint_info = {}
        self.selected_storage_info = {}
        self.sch_datetime = None
        self.sch_frequency = None
        self.sch_day =  None
        self.virtual_machines = ["VM 1", "VM 2", "VM 3", "VM 4"]
        self.applications = ['APP ONE', 'APP TWO', 'APP THREE', 'APP FOUR']

    def create_widgets(self):
        # Title Frame
        self.title_frame = gui.CTkFrame(self)
        self.title_frame.grid(row=0, column=0, columnspan=3, sticky="ew")

        title_label = gui.CTkLabel(self.title_frame, text="Create Backup Job", font=gui.CTkFont(size=20, weight="bold"))
        title_label.pack(pady=(10, 20))

        # Form Body Frame
        self.form_frame = gui.CTkFrame(self, fg_color="#000000")
        self.form_frame.grid(row=1, column=0, columnspan=3, sticky="nsew", padx=40, pady=20)

        # Row 1: Backup Description, Endpoint
        backup_job_label = gui.CTkLabel(self.form_frame, text="Backup Job Name")
        backup_job_label.grid(row=0, column=0, padx=(20, 5), pady=(20, 5), sticky="w")

        self.backup_job_name = gui.CTkEntry(self.form_frame, fg_color="#FFFFFF", border_color="#FFFFFF", text_color="#000000")
        self.backup_job_name.bind("<FocusOut>", lambda event: self.master_validator(widget_label="job_name", event=event))
        self.backup_job_name.grid(row=1, column=0, padx=(20, 5), pady=(5, 5), sticky="ew")

        endpoint_label = gui.CTkLabel(self.form_frame, text="Select Endpoint")
        endpoint_label.grid(row=0, column=1, padx=(5, 20), pady=(20, 5), sticky="w")

        endpoints = self.fetch_objects("endpoint_names")
        endpoints.insert(0, "-Select an Option-")
    
        self.endpoint_dropdown = gui.CTkComboBox(self.form_frame, values=endpoints, dropdown_fg_color="#FFFFFF", dropdown_text_color="#000000", fg_color="#FFFFFF", border_color="#FFFFFF", text_color="#000000", command=lambda selected_endpoint: self.activate_browse_button(selected_endpoint))
        self.endpoint_dropdown.grid(row=1, column=1, padx=(5, 20), pady=(5, 5), sticky="ew")
        
        self.browse_items_button = gui.CTkButton(self.form_frame, state=tk.DISABLED, text="Select an Endpoint To Browse", fg_color="#2b2b2b", command=self.browse_object)
        self.browse_items_button.grid(row=2, column=0, columnspan=2, pady=(10, 5), padx=20, sticky="ew")

        # Row 3: Storage Node, Browse Destination
        storage_node_label = gui.CTkLabel(self.form_frame, text="Primary Storage Node")
        storage_node_label.grid(row=3, column=0, padx=(20, 5), pady=(5, 5), sticky="w")

        storagenodes = self.fetch_objects("storage_names")
        storagenodes.insert(0, "-Select an Option-")

        self.storage_node_dropdown = gui.CTkComboBox(self.form_frame, values=storagenodes, fg_color="#2b2b2b", border_color="#2b2b2b", text_color="#000000", state=tk.DISABLED, command= lambda selected_storage: self.activate_select_destination(selected_storage))
        self.storage_node_dropdown.bind("<FocusOut>", lambda event: self.master_validator(widget_label="storage_node_val", event=event))
        self.storage_node_dropdown.grid(row=4, column=0, padx=(20, 5), pady=(5, 5), sticky="ew")

        self.browse_destination_button = gui.CTkButton(self.form_frame, text="Select Backup Destination", state=tk.DISABLED, fg_color="#2b2b2b", command= self.select_storage_destination)
        self.browse_destination_button.grid(row=4, column=1, padx=(5, 20), pady=(5, 5), sticky="ew")
        

        # Row 5: Make Copies On Another Storage Node Switch + Add another storage button.
        self.copy_switch_var = tk.BooleanVar()
        self.copy_switch = gui.CTkSwitch(self.form_frame, text="Make Copies On Other Storage Nodes", variable=self.copy_switch_var)
        self.copy_switch.grid(row=5, column=0, pady=(20, 5), padx=20, sticky="ew", columnspan=2)

        self.add_storage_button = gui.CTkButton(self.form_frame, text="Add Another Storage", fg_color="#2b2b2b", state=tk.DISABLED)
        self.add_storage_button.grid(row=5, column=1, pady=(20, 5), padx=20, sticky="ew")

        # Row 6: Scrollable Frame for Additional Storage Nodes
        self.additional_storage_frame = gui.CTkScrollableFrame(self.form_frame, fg_color="#2b2b2b")
        self.additional_storage_frame.configure(height=100)
        self.additional_storage_frame._scrollbar.configure(height=10)
        self.additional_storage_frame.grid(row=6, column=0, columnspan=2, pady=(0,0), padx=20, sticky="ew")
        self.additional_storage_frame.grid_columnconfigure(0, weight=1)
        self.additional_storage_frame.grid_columnconfigure(1, weight=1)
        

        # Row within Scrollable Frame: Storage Node Dropdown and Choose Location Button
        self.additional_storage_node_dropdown = gui.CTkComboBox(self.additional_storage_frame, values=storagenodes, fg_color="#000000", border_color="#000000", text_color="#000000", state=tk.DISABLED)
        self.additional_storage_node_dropdown.grid(row=0, column=0, padx=(5, 5), pady=(5, 5), sticky="ew")

        self.choose_location_button = gui.CTkButton(self.additional_storage_frame, text="Choose Location", state=tk.DISABLED, fg_color="#000000")
        self.choose_location_button.grid(row=0, column=1, padx=(5, 5), pady=(5, 5), sticky="ew")

        # Row 7: Backup Now, Schedule Backup
        self.backup_now_button = gui.CTkButton(self.form_frame, text="Backup Now", state=tk.DISABLED, fg_color="#2b2b2b", command=self.backup_now)
        self.backup_now_button.grid(row=7, column=0, padx=(20, 5), pady=(20,5), sticky="ew")

        self.schedule_backup_button = gui.CTkButton(self.form_frame, text="Schedule Backup", state=tk.DISABLED, fg_color="#2b2b2b", command=self.schedule_job)
        self.schedule_backup_button.grid(row=7, column=1, padx=(5, 20), pady=(20, 5), sticky="ew")

        # Adjusted column configurations
        self.form_frame.columnconfigure(0, weight=1)
        self.form_frame.columnconfigure(1, weight=1)

        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=1)
        self.rowconfigure(1, weight=1)

    def fetch_objects(self, obj_type):
        try:
            objects = CommonMethods.get_objects(obj_type, self.master.app_name, self.master.windows_user)
            if objects == None:
               tk.messagebox.showerror("Failed to Get Items", f"Failed to get requested items")
               return objects
            else:
                return objects
        except Exception as e:
            tk.messagebox.showerror("Fetch Error", f"An Application Error Occurred, report this to ZeroDown.")
            return None


    def get_endpoint_volumes(self, endpoint_name):
        resource_url= f"http://127.0.0.1:8080/zeroapi/v1/endpoint/listing/{endpoint_name.lower()}"
        zauth_token = self.master.retrieve_auth_token()
        zeroheaders = {"Authorization": f"Bearer {zauth_token}", "Content-Type": "application/json"}
        del zauth_token
        try:
            response = requests.get( resource_url, stream=True, headers=zeroheaders)
            response.raise_for_status()
            self.volumes_with_size = json.loads(response.json())
            for obj in self.volumes_with_size:
                self.volumes.append(obj)
        except requests.exceptions.RequestException as e:
            tk.messagebox.showerror("Fetch Error", f"Failed to fetch {e}")
            #return -1
        except Exception as e:
            print("ERROR IS",e)
            tb = traceback.extract_tb(e.__traceback__)
            last_frame = tb[-1]
            if tb:
                lineno = last_frame.lineno
                print("LINE NUM IS", lineno)
            tk.messagebox.showerror("Fetch Error", f"An Application Error Occurred, report this to ZeroDown.")
            #return -1

    def get_storage_volumes(self, storage_name):
        resource_url= f"http://127.0.0.1:8080/zeroapi/v1/storage/volumes/{storage_name.lower()}"
        zauth_token = self.master.retrieve_auth_token()
        zeroheaders = {"Authorization": f"Bearer {zauth_token}", "Content-Type": "application/json"}
        del zauth_token
        try:
            response = requests.get( resource_url, stream=True, headers=zeroheaders)
            response.raise_for_status()
            self.volumes_with_size = json.loads(response.json())
            for obj in self.volumes_with_size:
                self.volumes.append(obj)
        except requests.exceptions.RequestException as e:
            tk.messagebox.showerror("Fetch Error", f"Failed to fetch {e}")
            #return -1
        except Exception as e:
            print("ERROR IS",e)
            tb = traceback.extract_tb(e.__traceback__)
            last_frame = tb[-1]
            if tb:
                lineno = last_frame.lineno
                print("LINE NUM IS", lineno)
            tk.messagebox.showerror("Fetch Error", f"An Application Error Occurred, report this to ZeroDown.")
            #return -1

    def activate_browse_button(self, selected_endpoint):
        if selected_endpoint !="" and selected_endpoint != "-Select an Option-":
            self.browse_items_button.configure(state=tk.NORMAL, fg_color="#1F6AA5", text=f"Browse {selected_endpoint} Backup Items")
        else:
            self.browse_items_button.configure(state=tk.DISABLED, fg_color="#2b2b2b", text="Select an Endpoint To Browse")
    
    def activate_select_destination(self, selected_storage):
        storage_node_val =  self.master_validator(widget_label="storage_node_val")
        if storage_node_val < 1:
            return -1
        self.selected_storage= selected_storage
        self.get_storage_volumes(selected_storage)
        self.browse_destination_button.configure(state="normal", fg_color="#1F6AA5")


    def browse_object(self):
        self.backup_demand = 0.00
        self.endpoint_name=self.endpoint_dropdown.get()
        title = f'{self.browse_items_button.cget("text")}'
        self.get_endpoint_volumes(self.endpoint_name)
        RemoteExplorer(self, title, self.endpoint_name, "endpoint", "backup")

    def select_storage_destination(self):
        title = f' Storage Nodes on {self.selected_storage}'
        RemoteExplorer(self, title, self.selected_storage, "storage", "backup")


    def backup_now(self):
        job_name_vf = self.master_validator(widget_label="job_name") #job name validation factor
        storage_node_vf = self.master_validator(widget_label="storage_node_val") #storage node validation factor
        endpoint_vf = self.master_validator(widget_label="endpoint_val") #endpoint  validation factor

        if  job_name_vf <= 0:
            tk.messagebox.showerror("Invalid Job Name", "You must enter a valid Job Name")

        if storage_node_vf <= 0:
            tk.messagebox.showerror("Invalid Storage Node Selection", "You Must Select A Storage Node")
        
        if endpoint_vf <= 0:
             tk.messagebox.showerror("Invalid Endpoint Selection", "You Must Select An Endpoint")

        if  not job_name_vf <= 0 and not storage_node_vf <= 0 and not endpoint_vf <= 0:
            resource_url= f"http://127.0.0.1:8080/zeroapi/v1/backup/first_time"
            zauth_token = self.master.retrieve_auth_token()
            zeroheaders = {"Authorization": f"Bearer {zauth_token}", "Content-Type": "application/json"}
            try:
                response = requests.post( resource_url, stream=True, headers=zeroheaders, json={"endpoint_name" : self.endpoint_name, "backup_targets": self.selected_endpoint_info, "backup_destinations": self.selected_storage_info, "name": self.backup_job_name.get()})
                response.raise_for_status()
                response= response.json()
                in_progress_num = response['in_progress']
                job_id = response['job_id']

                if  in_progress_num >= 1:
                    title = f"Backup Job: {self.backup_job_name.get()} In Progress"
                    JobStatus(self, title, in_progress_num, job_id )
                else:
                    tk.messagebox.showerror("Backup Error", f"Something Went Wrong: Failed to start backup")

            except requests.exceptions.RequestException as e:
                tk.messagebox.showerror("Backup Error", f"An unexpected error occurred. Please try again or contact ZeroDown Support for help.")


    def master_validator(self, widget_label, event=None):
        if widget_label == "job_name":
            if  self.backup_job_name.get() == None or self.backup_job_name.get() == ""  or self.backup_job_name.get() == "Name this Backup Job":
                self.backup_job_name.configure(text_color="#cc3300")
                self.backup_job_name.delete(0, "end")
                self.backup_job_name.insert(0,f"Name this Backup Job")
                return 0
            else:
                self.backup_job_name.configure(text_color="#000000")
                return 1
        
        if widget_label == "endpoint_val":
            if  self.endpoint_dropdown.get() == "-Select an Option-":
                self.browse_items_button.configure(state="disabled")
                return 0
            else:
                self.browse_items_button.configure(state="normal")
                return 1
            

        if widget_label == "storage_node_val":
            if  self.storage_node_dropdown.get() == "-Select an Option-":
                self.browse_destination_button.configure(state="disabled")
                return 0
            else:
                self.browse_destination_button.configure(state="normal")
                return 1

        return -1
    
    def schedule_job(self):
        job_name_vf = self.master_validator(widget_label="job_name") #job name validation factor
        storage_node_vf = self.master_validator(widget_label="storage_node_val") #storage node validation factor
        endpoint_vf = self.master_validator(widget_label="endpoint_val") #endpoint  validation factor

        if  job_name_vf <= 0:
            tk.messagebox.showerror("Invalid Job Name", "You must enter a valid Job Name")

        if storage_node_vf <= 0:
            tk.messagebox.showerror("Invalid Storage Node Selection", "You Must Select A Storage Node")
        
        if endpoint_vf <= 0:
             tk.messagebox.showerror("Invalid Endpoint Selection", "You Must Select An Endpoint")

        if  not job_name_vf <= 0 and not storage_node_vf <= 0 and not endpoint_vf <= 0:
            ScheduleJob(self, "Scheduling Job", job_name=self.backup_job_name.get() )
    